<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>沈新新的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="沈新新的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="沈新新的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="沈新新的博客">
  
    <link rel="alternate" href="/atom.xml" title="沈新新的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="index.html" id="logo">沈新新的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="index.html">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-learnJava1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2018/03/06/learnJava1/" class="article-date">
  <time datetime="2018-03-05T16:06:46.000Z" itemprop="datePublished">2018-03-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2018/03/06/learnJava1/">Java程序设计教程（第二版）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h5><ul>
<li>强制类型转换：将强类型转换成弱类型。会丢失一部分精度</li>
<li>隐式类型转换：将弱类型转换成强类型。不需要显式类型转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 四舍五入</span><br><span class="line">int i = (int)(d + 0.5)</span><br></pre></td></tr></table></figure>
<pre><code>布尔类型不能与其他基本数据类型的数据进行相互的数据类型转换
</code></pre><h5 id="布尔逻辑运算符"><a href="#布尔逻辑运算符" class="headerlink" title="布尔逻辑运算符"></a>布尔逻辑运算符</h5><p>|| 和 | 的区别： ||采用的是短路规则，|没有采用短路规则</p>
<h5 id="异或运算的性质："><a href="#异或运算的性质：" class="headerlink" title="异或运算的性质："></a>异或运算的性质：</h5><p>(a ^ b) ^ b == a<br>(a ^ b) ^ a == b</p>
<h5 id="do-while的循环体至少会被执行一次"><a href="#do-while的循环体至少会被执行一次" class="headerlink" title="do-while的循环体至少会被执行一次"></a>do-while的循环体至少会被执行一次</h5><h5 id="垃圾回收机制的基本原理"><a href="#垃圾回收机制的基本原理" class="headerlink" title="垃圾回收机制的基本原理"></a>垃圾回收机制的基本原理</h5><p>在适当的时机自动回收不再被Java程序所用的内存。这些不再被java程序所用的内存成为垃圾。<br>对于一个实例对象，如果没有任何引用指向该实例对象，则该实例对象所占据的内存是不再被java程序所用的内存。</p>
<h5 id="面向对象技术的3大特性：继承性、多态性、封装性"><a href="#面向对象技术的3大特性：继承性、多态性、封装性" class="headerlink" title="面向对象技术的3大特性：继承性、多态性、封装性"></a>面向对象技术的3大特性：继承性、多态性、封装性</h5><ul>
<li><p>继承性： 当前定义的类的构造方法必须调用其直接父类的构造方法。如果在当前定义的类的构造函数中没有显式地写上调用父类的构造方法的语句，则Java虚拟机一般会自动在当前定义的类的构造方法的第一条语句前自动地隐式地添加不含任何参数的直接父类构造方法的语句。</p>
</li>
<li><p>多态性：在类定义中出现多个构造方法或出现多个同名的成员方法。<br>多态性包括两种类型：静态多态性和动态多态性。</p>
</li>
</ul>
<p>静态多态性指的是在同一个类中同名方法在功能上的重载。要求同名的方法具有不同的参数列表。<br>不同的参数列表指的是方法的参数个数不同，数据类型不同活着排列顺序不同。<br>动态多态性指的是子类和父类的类体中均定义了具有基本相同声明的非静态成员方法。<br>利用动态多态性使得可以通过父类型的引用调用子类型的成员方法。</p>
<ul>
<li>封装性：可以通过封装性使得各个模块的外在表现仅仅为对一些成员域的访问方式和一些成员方法的调用方式，即屏蔽各个模块的内部具体实现方式。<br>类的访问方式有两种：公共模式和默认模式<br>类的成员的访问方式有四种：公共模式、保护模式、默认模式、私有模式</li>
</ul>
<h5 id="abstract、static、final"><a href="#abstract、static、final" class="headerlink" title="abstract、static、final"></a>abstract、static、final</h5><p>abstract：抽象<br>static：静态<br>final：最终</p>
<p>abstract：Java允许类、接口、成员方法具有抽象属性。无法通过抽象类的构造方法生成抽象类的实例对象。接口总是具有抽象属性。因此，不管在定义接口的修饰词列表中是否有关键字abstract，该接口都具有抽象属性。抽象成员方法一般在定义抽象类的类体或者接口的接口体中定义。如果一个类不具备抽象属性，则不能在该类中定义抽象成员方法。</p>
<p>抽象成员方法的定义格式与不具备抽象属性的成员方法之间的区别：除了是否含有修饰词abstract外，抽象成员方法是以分号结束，而且不含方法体。<br>如果抽象类型的子类型不是抽象类型，则要求在该子类的定义中必须定义覆盖抽象类型的所有抽象方法。这样，根据动态多态性，可以通过抽象类型的表达式访问抽象类型的成员域以及调用这些被覆盖的成员方法来实现。使得程序具有较好的可扩展性。</p>
<p>static：除了内部类以外，类一般不能具有静态属性。类的成员域和成员方法可以具有静态属性。<br>        在定义静态成员方法的方法体中不能采用关键字this</p>
<p>final：可以用来修饰不具有抽象属性的类、类的成员域、接口的成员域以及类的不具有抽象属性的成员方法。具有最终属性的类不能派生出子类。如果成员域具有最终属性和静态属性，则该成员域只能在定义的时候赋值，且不能被修改。如果成员域具有最终属性，但没有静态属性，则该成员域只能在定义时或者在构造方法中赋值，而且只能赋值一次。</p>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>接口的成员方法只能是抽象成员方法。接口的所有成员方法都具有public和abstract属性。</p>
<h5 id="变量作用域范围"><a href="#变量作用域范围" class="headerlink" title="变量作用域范围"></a>变量作用域范围</h5><ul>
<li>静态成员具有全剧作用域范围</li>
<li>不具有静态属性的成员域具有类作用域范围。</li>
<li>成员方法或构造方法的参数变量以及在方法体中定义的局部变量具有块作用域范围。</li>
</ul>
<h5 id="面向对象程序设计的基本思想："><a href="#面向对象程序设计的基本思想：" class="headerlink" title="面向对象程序设计的基本思想："></a>面向对象程序设计的基本思想：</h5><ul>
<li>分析实际需要求解的问题，从中提取需要设计的对象</li>
<li>编写这些对象所对应的类</li>
<li>通过集成这些对象的功能解决需要求解的问题</li>
</ul>
<h5 id="接口和抽象类之间的区别："><a href="#接口和抽象类之间的区别：" class="headerlink" title="接口和抽象类之间的区别："></a>接口和抽象类之间的区别：</h5><ul>
<li>在抽象类中可以写非抽象的方法，在接口中不可以</li>
<li>类只能继承一个抽象类/父类，但是可以实现多个接口</li>
</ul>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><h5 id="哈希表的基本原理"><a href="#哈希表的基本原理" class="headerlink" title="哈希表的基本原理"></a>哈希表的基本原理</h5><pre><code>在哈希表的元素的关键字与该元素的存储位置之间建立起一种映射关系。这种映射关系称为哈希函数或散列函数。由哈希函数计算出来的数值称为哈希码或散列索引。
</code></pre><h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><pre><code>与面向对象的多态性相类似，应用泛型可以提高程序的复用性。与多态性不同的是，应用泛型可以减少数据的类型转换，从而提高代码的运行效率。实际上是通过给类或接口增加类型参数实现的
</code></pre><h5 id="for语句的简化写法"><a href="#for语句的简化写法" class="headerlink" title="for语句的简化写法"></a>for语句的简化写法</h5><p>第一类for语句的简化写法要求具有成员方法public Interator<e> iterator()</e></p>
<h5 id="递归方法："><a href="#递归方法：" class="headerlink" title="递归方法："></a>递归方法：</h5><p>在方法定义中直接或间接地调用该方法本身，就称为递归。<br>分解技术：将愿问题分解成规模较小的同类问题。</p>
<h5 id="Tower-of-Hanoi"><a href="#Tower-of-Hanoi" class="headerlink" title="Tower of Hanoi"></a>Tower of Hanoi</h5><ol>
<li>将原始柱子S上的n-1个盘从原始柱子S借助于目标柱子E移动到临时柱子T上</li>
<li>将原始柱子S上剩下的唯一的盘从原始柱子S移动到目标柱子E上</li>
<li>将临时柱子T上的盘从临时柱子T借助原始柱子S移动到目标柱子E上</li>
</ol>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>当且仅当要求某一个类只能有一个实例对象时，才能考虑使用单例模式。</p>
<p>TODO 看看其他设计模式</p>
<h5 id="编程规范和程序调试"><a href="#编程规范和程序调试" class="headerlink" title="编程规范和程序调试"></a>编程规范和程序调试</h5><p>编程规范在一定程度上可以使每个程序员在编程风格上尽量保持一致，提高程序的可理解性，从而提高软件的健壮性，降低软件的开发和维护成本。</p>
<p>编写规范包括：命名规范、排版规范、语句规范和文件组织规范等4个部分的内容。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/06/learnJava1/" data-id="cjeef5siz0000qx9l0deslv6d" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-learngit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2018/02/23/learngit/" class="article-date">
  <time datetime="2018-02-23T09:17:39.000Z" itemprop="datePublished">2018-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2018/02/23/learngit/">廖雪峰git教程笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先贴上官方网站：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>
<p>以下是学习过程中的笔记。</p>
<h4 id="集中式版本控制系统-vs-分布式版本控制系统"><a href="#集中式版本控制系统-vs-分布式版本控制系统" class="headerlink" title="集中式版本控制系统 vs 分布式版本控制系统"></a>集中式版本控制系统 vs 分布式版本控制系统</h4><ul>
<li><p>集中式版本控制系统：版本库集中存放在中央服务器，需要联网才能工作</p>
</li>
<li><p>分布式版本控制系统：每个人电脑上都是一个完整的版本库。</p>
</li>
<li><p>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但是这个服务器的作用仅仅用来方便“交换”大家的修改</p>
</li>
</ul>
<h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><ul>
<li><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</p>
</li>
<li><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>
</li>
<li><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>
</li>
</ul>
<p>在Git中， 用<em>HEAD</em>表示当前版本</p>
<h4 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h4><pre><code>Git管理的是修改，而不是文件
git checkout -- file可以丢弃工作区的修改
</code></pre><p>用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p>
<p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p>
<h5 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h5><pre><code>查看分支：git branch

创建分支：git branch &lt;name&gt;

切换分支：git checkout &lt;name&gt;

创建+切换分支：git checkout -b &lt;name&gt;

合并某分支到当前分支：git merge &lt;name&gt;

删除分支：git branch -d &lt;name&gt;
</code></pre><h5 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h5><p>用git log –graph命令可以看到分支合并图。</p>
<h5 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h5><p>通常在合并分支的时候，如果可能Git会用Fast forward模式，但是，在这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用Fast forward模式，Git会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<h5 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h5><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</name></p>
<h5 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h5><ul>
<li><p>首先，可以试图用git push origin branch-name推送自己的修改；</p>
</li>
<li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p>
</li>
<li><p>如果合并有冲突，则解决冲突，并在本地提交；</p>
</li>
<li><p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p>
</li>
</ul>
<p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。</p>
<h4 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h4><p>发布一个版本的时候，我们通常在版本库中打一个标签，这样就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以标签也是版本库的一个快照。</p>
<p>其本质是指向某个commit的指针</p>
<p>分支vs标签： 分支可以移动，标签不可以</p>
<p>为什么要引入tag：tag是一个更容易让人记住的有意义的名字，它跟某个commit绑在一起。</p>
<pre><code>命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；

git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息；

git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签；

命令git tag可以查看所有标签。
</code></pre><p>操作标签：</p>
<pre><code>命令git push origin &lt;tagname&gt;可以推送一个本地标签；

命令git push origin --tags可以推送全部未推送过的本地标签；

命令git tag -d &lt;tagname&gt;可以删除一个本地标签；

命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。
</code></pre><h5 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h5><p>忽略某些文件时，需要编写.gitignore；</p>
<p>.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！</p>
<h5 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h5><pre><code>git config --global alias.st status
git config --global alias.co checkout
git config --global alias.ci commit
git config --global alias.br branch
git config --global alias.unstage &apos;reset HEAD&apos;
// 散心病狂？ nonono 一点都不
git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;
</code></pre><h5 id="–hard参数的意义？"><a href="#–hard参数的意义？" class="headerlink" title="–hard参数的意义？"></a>–hard参数的意义？</h5><p>文章中说要告诉我hard的意义，但是…然后就没有然后了。<br>查了一下，下面三幅图我觉得能比较直观地解释。<br>–soft<br><img src="/2018/02/23/learngit/182237338854646.png"><br>–mixed（default）<br><img src="/2018/02/23/learngit/182238202609380.png"><br>–hard<br><img src="/2018/02/23/learngit/182238305101646.png"></p>
<p>参考链接：<a href="http://www.cnblogs.com/kidsitcn/p/4513297.html" target="_blank" rel="noopener">http://www.cnblogs.com/kidsitcn/p/4513297.html</a></p>
<p>工作区—-暂存区—-分支</p>
<h5 id="Problem-amp-Solution"><a href="#Problem-amp-Solution" class="headerlink" title="Problem &amp; Solution"></a>Problem &amp; Solution</h5><p>Problem1:</p>
<pre><code>refusing to merge unrelated histories
</code></pre><p>Solution:</p>
<pre><code>You can use --allow-unrelated-histories to force the merge to happen.
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/23/learngit/" data-id="cjeef5sj60001qx9lizl924ya" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/git/">git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-what-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2018/02/21/what-2/" class="article-date">
  <time datetime="2018-02-20T17:23:36.000Z" itemprop="datePublished">2018-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2018/02/21/what-2/">What happens when ...?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="按下”g”键"><a href="#按下”g”键" class="headerlink" title="按下”g”键"></a>按下”g”键</h2><blockquote>
<p>相关知识点：物理键盘和系统中断的工作原理</p>
</blockquote>
<h6 id="按下一颗键后，系统怎么知道你按的是哪颗？"><a href="#按下一颗键后，系统怎么知道你按的是哪颗？" class="headerlink" title="按下一颗键后，系统怎么知道你按的是哪颗？"></a>按下一颗键后，系统怎么知道你按的是哪颗？</h6><ul>
<li><ol>
<li>产生码值</li>
</ol>
</li>
</ul>
<blockquote>
<p>我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。</p>
</blockquote>
<ul>
<li><ol>
<li>传输到操作系统</li>
</ol>
</li>
</ul>
<blockquote>
<p>现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的。这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层。</p>
</blockquote>
<ul>
<li><ol>
<li>消息发往应用程序</li>
</ol>
</li>
</ul>
<blockquote>
<p>操作系统讲信号进行翻译成键码值，传给当前活跃的窗口／应用程序。</p>
</blockquote>
<h6 id="浏览器地址栏怎么处理你输入的那个值？"><a href="#浏览器地址栏怎么处理你输入的那个值？" class="headerlink" title="浏览器地址栏怎么处理你输入的那个值？"></a>浏览器地址栏怎么处理你输入的那个值？</h6><blockquote>
<p>当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。</p>
</blockquote>
<p><img src="media/15011257367118/15011271175884.jpg" alt=""></p>
<h2 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h2><p>用户按下回车之后，浏览器开始解析URL的工作。</p>
<ul>
<li><ol>
<li>判断URL是否合法？</li>
</ol>
</li>
</ul>
<blockquote>
<p>当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。<br><img src="media/15011257367118/15011271911500.jpg" alt=""></p>
</blockquote>
<ul>
<li><ol>
<li>检查 HSTS 列表</li>
</ol>
</li>
</ul>
<blockquote>
<p>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站。如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送</p>
</blockquote>
<h2 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h2><blockquote>
<p>查询顺序：浏览器缓存-本地hosts-DNS服务器</p>
</blockquote>
<ul>
<li>1.浏览器缓存<br>  要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns</li>
<li>2.本地hosts<br>  调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询</li>
<li>3.DNS服务器<br>  如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询。<br>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 <strong>ARP 过程</strong>对默认网关进行查询</li>
</ul>
<h2 id="ARP过程"><a href="#ARP过程" class="headerlink" title="ARP过程"></a>ARP过程</h2><p>ARP(Address Resolution Protocol)地址解析协议</p>
<p>需要：<br>目标IP地址 、<br>用于发送 ARP 广播的接口的 MAC 地址</p>
<ol>
<li>首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC</li>
<li>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。查询选择的网络接口的 MAC 地址</li>
<li>我们发送一个二层（ OSI 模型 中的数据链路层）ARP 请求</li>
</ol>
<p>##TCP连接<br>现在我们已经知道google.com的IP地址了，接下来浏览器会调用系统库函数 socket ，请求一个 TCP流套接字。</p>
<ol>
<li>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment</li>
<li>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，把它封装成一个TCP packet</li>
<li>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame头 部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。</li>
</ol>
<p><em>TCP封包is ready</em></p>
<h6 id="建立TCP连接："><a href="#建立TCP连接：" class="headerlink" title="建立TCP连接："></a>建立TCP连接：</h6><p>TCP连接的整个过程，用一张图来描述一下（图片来源：网络）<br><img src="media/15011257367118/15012107324446.jpg" alt=""><br>首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发送报文，并分配资源，这样TCP连接就建立了</p>
<h2 id="SSL／TSL协议的握手过程"><a href="#SSL／TSL协议的握手过程" class="headerlink" title="SSL／TSL协议的握手过程"></a>SSL／TSL协议的握手过程</h2><pre><code>使用SSL/TLS的HTTP通信，就是传说中的HTTPS。
用户访问HTTPS头的地址，就需要进行SSL／TSL握手过程。
</code></pre><blockquote>
<p>原理：SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。<br>bg2014020502.png<br><img src="/2018/02/21/what-2/bg2014020502.png" title="图片来源：阮一峰的网络日志"></p>
</blockquote>
<p>更多信息参考：<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a> </p>
<h2 id="服务器端处理请求"><a href="#服务器端处理请求" class="headerlink" title="服务器端处理请求"></a>服务器端处理请求</h2><p>现在，我们已经建立客户端和服务器端的连接了。服务器是怎么处理我们发过去的请求的呢？</p>
<ol>
<li>服务器端收到请求后，会把请求拆分为几个参数：<strong>HTTP 请求方法、域名、请求路径</strong>。</li>
<li>服务器验证其上已经配置了 google.com 的虚拟主机</li>
<li>服务器验证 google.com 接受 GET 方法</li>
<li>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)</li>
<li>服务器根据请求信息获取相应的响应内容</li>
<li>服务器会使用指定的处理程序分析处理这个文件</li>
</ol>
<h2 id="客户端收到服务端返回的资源"><a href="#客户端收到服务端返回的资源" class="headerlink" title="客户端收到服务端返回的资源"></a>客户端收到服务端返回的资源</h2><h6 id="网页资源被解释成DOM树"><a href="#网页资源被解释成DOM树" class="headerlink" title="网页资源被解释成DOM树"></a>网页资源被解释成DOM树</h6><ol>
<li>网页被交给HTML解释器转变成一系列的Token</li>
<li>解释器根据Token构建Node，形成DOM树</li>
<li>如果节点是JS代码的话，调用JavaScript引擎解释并执行。</li>
<li>如果节点需要依赖其他资源，如图片、CSS、视频等，调用资源加载器来加载他们。</li>
</ol>
<h6 id="CSS文件被解释成CSSOM树"><a href="#CSS文件被解释成CSSOM树" class="headerlink" title="CSS文件被解释成CSSOM树"></a>CSS文件被解释成CSSOM树</h6><ol>
<li>CSS文件被CSS解释器解释成内部表示结构。</li>
<li>CSS解释器工作完之后，在DOM树上附加解释后的样式信息，即RenderObject树。</li>
<li>RenderObject节点在创建的同时，WebKit会根据网页的层次结构创建RenderLayer树，同时构建一个虚拟的绘图上下文。</li>
</ol>
<h6 id="根据绘图上下文来生成最终的图像"><a href="#根据绘图上下文来生成最终的图像" class="headerlink" title="根据绘图上下文来生成最终的图像"></a>根据绘图上下文来生成最终的图像</h6><p>这一过程主要依赖2D和3D图形库</p>
<ol>
<li>绘图上下文将每个绘图操作桥接到不同的绘图具体实现类</li>
<li>绘图实现类将2D图形库或3D图形库绘制的结果保存下来，交给浏览器进行显示。</li>
</ol>
<p>绘图有软件渲染、GPU硬件渲染、混合渲染模型等方式。</p>
<p>由于网页的动画或者用户的交互，浏览器其实一直在不停地重复执行渲染过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/21/what-2/" data-id="cjeef5sje0004qx9lwz82lj8e" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/basic/">basic</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/tech/">tech</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tomato" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2018/02/12/tomato/" class="article-date">
  <time datetime="2018-02-12T08:31:27.000Z" itemprop="datePublished">2018-02-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="categories/other/">other</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2018/02/12/tomato/">tomato</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h1><blockquote>
<p>努力工作却感觉工作越做越多？工作中常常被人打断，无法集中？和我一样有严重的拖延症？经常加班，没时间陪家人？试试番茄工作法吧。</p>
</blockquote>
<h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><pre><code>在25分钟内专心做一件事，然后彻底休息5分钟
</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre><code>番茄工作法有5个阶段：计划、跟踪、记录、处理、可视化。
</code></pre><p>说说我是怎么做的吧，这个是基本的流程。</p>
<ol>
<li>列TODO LIST，也就是<strong>活动清单</strong>。写上你近期要做的一些事情。如果是有deadline的，在后面标注截止时间。</li>
<li>评估每项任务需要的番茄钟（一个番茄钟25分钟）。</li>
<li>每天上班的时候，从<strong>活动清单</strong>中提取最重要、紧急的活动，移到今天的<strong>今日待办</strong>中。一般一天会安排8个左右番茄钟的活动。</li>
<li>开启25分钟的番茄钟，进入番茄时间。</li>
<li>在番茄时间内，难免有被人打断的时候。要跟踪自己的中断次数。如果事情不紧急，记入<strong>活动清单</strong>，之后再进行处理。如果事情紧急，必须马上进行，则废弃当前的番茄钟。</li>
<li>25分钟时间到之后，无论正在进行什么活动，马上停止，进入5分钟的休息时间。</li>
<li><strong>休息时间彻底休息</strong>，可以走一走，喝喝水，放空大脑。千万不要想之前的活动，反正把大脑放空就对了。</li>
<li>休息时间到之后，进入下一个番茄钟。依此类推。</li>
<li>在一天的工作结束之后，对当天的数据进行归档，并回顾一天的工作，从数据中找出改进流程的思路。</li>
</ol>
<blockquote>
<p>注意事项：</p>
<ol>
<li>活动清单上的待办事项不要太多，不要超过一周的量。因为，活动太多会让人很容易焦虑的。</li>
<li>对超过4个番茄钟的活动，我一般都会进行拆解。比如写一个页面，会拆解成样式部分、JS逻辑、接口联调等。好处是：小目标时间的预估会更加准确；目标得到达成，有种被小小激励到的感觉。</li>
<li>活动具有原子性，即一次只做一件事情</li>
</ol>
</blockquote>
<p>实际上，我在数据的处理上没有很花心思，这也是在实践中需要改进的地方。</p>
<h4 id="工具推荐："><a href="#工具推荐：" class="headerlink" title="工具推荐："></a>工具推荐：</h4><p>推荐一下我常用的一些桌面应用和手机APP。iphone和Mac的，可能对windows和安卓用户不大友好。不过工具只是工具，大家可以找适合自己的。另外，会向大家介绍我平时是怎么使用这些工具进行时间管理。</p>
<h5 id="工具（原始版）："><a href="#工具（原始版）：" class="headerlink" title="工具（原始版）："></a>工具（原始版）：</h5><pre><code>3张清单：
   活动清单
   今日待办
   记录
1个计时器：
    番茄钟
</code></pre><h5 id="工具（app版）吐血推荐："><a href="#工具（app版）吐血推荐：" class="headerlink" title="工具（app版）吐血推荐："></a>工具（app版）吐血推荐：</h5><pre><code>计时器：
    潮汐 --手机APP
    Focus --Mac桌面


活动清单：
    Things --Mac桌面
记录分析：
    时间块 --iPhone
</code></pre><p>再说啰嗦一句，工具不在多，而在精。用得顺手就只要那么几个就可以了，不要频繁更换。因为，一般的工具都有统计功能，可以统计你一周，一个月，一年的数据，对后期的分析有好处。</p>
<p>最后，希望番茄工作法能在实际工作中帮到你。</p>
<p>参考：<br>    《番茄工作法图解》<a href="https://book.douban.com/subject/5916234/" target="_blank" rel="noopener">https://book.douban.com/subject/5916234/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/12/tomato/" data-id="cjeef5sj90002qx9lxhkggqdl" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Efficiency/">Efficiency</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="categories/other/">other</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="tags/Efficiency/">Efficiency</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/basic/">basic</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/tech/">tech</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="tags/Efficiency/" style="font-size: 10px;">Efficiency</a> <a href="tags/basic/" style="font-size: 10px;">basic</a> <a href="tags/git/" style="font-size: 10px;">git</a> <a href="tags/tech/" style="font-size: 10px;">tech</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="2018/03/06/learnJava1/">Java程序设计教程（第二版）</a>
          </li>
        
          <li>
            <a href="2018/02/23/learngit/">廖雪峰git教程笔记</a>
          </li>
        
          <li>
            <a href="2018/02/21/what-2/">What happens when ...?</a>
          </li>
        
          <li>
            <a href="2018/02/12/tomato/">tomato</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 沈新新<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="fancybox/jquery.fancybox.css">
  <script src="fancybox/jquery.fancybox.pack.js"></script>


<script src="js/script.js"></script>



  </div>
</body>
</html>